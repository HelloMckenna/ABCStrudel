<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ABC â†’ Strudel Converter</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #f9fafb;
      color: #222;
      margin: 2em auto;
      max-width: 900px;
      line-height: 1.6;
    }
    h1 { text-align: center; }
    textarea {
      width: 100%;
      height: 240px;
      font-family: monospace;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #bbb;
      resize: vertical;
      box-sizing: border-box;
    }
    select, button {
      margin-top: 10px;
      padding: 10px 15px;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    button {
      background: #0072ff;
      color: white;
      border: none;
    }
    button:hover { background: #005fd1; }
    pre {
      background: #111;
      color: #0f0;
      padding: 15px;
      border-radius: 8px;
      white-space: pre-wrap;
      overflow-x: auto;
      font-size: 0.9rem;
    }
    .footer {
      margin-top: 3em;
      text-align: center;
      font-size: 0.8rem;
      color: #666;
    }

    /* Simple modal styles for manual-copy fallback */
    .copy-overlay {
      position: fixed;
      left: 0; top: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,.45);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .copy-modal {
      background: #fff;
      border-radius: 8px;
      padding: 16px;
      max-width: 700px;
      width: calc(100% - 40px);
      box-shadow: 0 8px 24px rgba(0,0,0,.2);
    }
    .copy-modal textarea {
      height: 180px;
      margin-top: 8px;
    }
    .copy-modal .copy-actions {
      margin-top: 8px;
      text-align: right;
    }
    .copy-modal .copy-actions button {
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <h1>ðŸŽµ ABC â†’ Strudel Converter</h1>
  <p>
    Paste your <a href="https://abcnotation.com/learn" target="_blank">ABC notation</a> below and click
    <b>Convert</b> to generate playable <a href="https://strudel.cc" target="_blank">Strudel</a> code.
  </p>

  <textarea id="abcInput" placeholder="Paste ABC here..."></textarea>
  <br>

  <label for="sound">Sound:</label>
  <select id="sound">
    <option value="piano">piano</option>
    <option value="pluck">pluck</option>
    <option value="saw">saw</option>
    <option value="bass">bass</option>
    <option value="synth">synth</option>
    <option value="drum">drum</option>
  </select>

  <button onclick="convertABC()">Convert</button>

  <h2>Generated Strudel Code:</h2>
  <pre id="strudelOutput"></pre>

  <div class="footer">Built for traditional musicians & live coders ðŸŽ»</div>

  <script>
    // Basic chromatic map
    const baseMap = {
      'C': 'c', '^C': 'c#', '_C': 'cb',
      'D': 'd', '^D': 'd#', '_D': 'db',
      'E': 'e', '^E': 'e#', '_E': 'eb',
      'F': 'f', '^F': 'f#', '_F': 'fb',
      'G': 'g', '^G': 'g#', '_G': 'gb',
      'A': 'a', '^A': 'a#', '_A': 'ab',
      'B': 'b', '^B': 'b#', '_B': 'bb'
    };

    // Major key accidental templates (adds sharps/flats automatically)
    const keyAccidentals = {
      // Major keys
      'Cmaj': [],
      'Gmaj': ['F#'],
      'Dmaj': ['F#', 'C#'],
      'Amaj': ['F#', 'C#', 'G#'],
      'Emaj': ['F#', 'C#', 'G#', 'D#'],
      'Bmaj': ['F#', 'C#', 'G#', 'D#', 'A#'],
      'Fmaj': ['Bb'],
      'Bbmaj': ['Bb', 'Eb'],
      'Ebmaj': ['Bb', 'Eb', 'Ab'],
      'Abmaj': ['Bb', 'Eb', 'Ab', 'Db'],

      // Natural minor keys (relative to major)
      'Amin': [],
      'Emin': ['F#'],
      'Bmin': ['F#', 'C#'],
      'F#min': ['F#', 'C#', 'G#'],
      'C#min': ['F#', 'C#', 'G#', 'D#'],
      'G#min': ['F#', 'C#', 'G#', 'D#', 'A#'],
      'Dmin': ['Bb'],
      'Gmin': ['Bb', 'Eb'],
      'Cmin': ['Bb', 'Eb', 'Ab'],
      'Fmin': ['Bb', 'Eb', 'Ab', 'Db'],

      // Dorian mode (one flat less than the relative minor, or one sharp more than relative major)
      'Ador': ['F#'],
      'Edor': ['F#', 'C#'],
      'Bdor': ['F#', 'C#', 'G#'],
      'F#dor': ['F#', 'C#', 'G#', 'D#'],
      'C#dor': ['F#', 'C#', 'G#', 'D#', 'A#'],
      'G#dor': ['F#', 'C#', 'G#', 'D#', 'A#', 'E#'],
      'Ddor': [],
      'Gdor': ['Bb'],
      'Cdor': ['Bb', 'Eb'],
      'Fdor': ['Bb', 'Eb', 'Ab'],

      // Mixolydian mode (one flat more than relative major, or one sharp less than relative major)
      'Amix': ['F#', 'C#'],
      'Emix': ['F#', 'C#','G#'],
      'Bmix': ['F#', 'C#','G#', 'D#'],
      'F#mix': ['F#', 'C#','G#', 'D#', 'A#'],
      'C#mix': ['F#', 'C#','G#', 'D#', 'A#', 'E#'],
      'G#mix': ['F#', 'C#','G#', 'D#', 'A#', 'E#', 'B#'],
      'Dmix': ['F#'],
      'Gmix': [],
      'Cmix': ['Bb'],
      'Fmix': ['Bb', 'Eb']
    };

    function parseHeader(lines) {
      const header = {};
      for (const line of lines) {
        if (/^T:/.test(line)) header.title = line.replace(/^T:\s*/, '');
        if (/^R:/.test(line)) header.rhythm = line.replace(/^R:\s*/, '');
        if (/^M:/.test(line)) header.meter = line.replace(/^M:\s*/, '');
        if (/^L:/.test(line)) header.length = line.replace(/^L:\s*/, '');
        if (/^K:/.test(line)) header.key = line.replace(/^K:\s*/, '').replace(/\s+/g, '');
      }
      return header;
    }

    // Convert |: to [[ and handle alternate endings
    function markRepeats(body) {
      // Handle alternate endings with |1 and |2
      // Pattern: |1 content :|2 content || (note: no space between :| and |2)
      body = body.replace(/\|1\s*(.+?):\|2\s*(.+?)\|\|/g, (match, ending1, ending2) => {
        // Use @SPLIT@ marker to indicate where second ending starts
        // Only wrap the whole alternate section with angle brackets
        return '|<' + ending1.trim() + '|@SPLIT@' + ending2.trim() + '>]]';
      });
      
      // Convert standard repeats |: to [[ and :| to ]]
      body = body.replace(/\|:/g, '[[').replace(/:\|/g, ']]');
      
      return body;
    }

    function splitBars(abc) {
      return abc
        .replace(/[{}~]/g, '') // ornaments
        .replace(/\([0-9]/g, '') // triplets
        .replace(/::/g, ':')
        .replace(/\n/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .split('|')
        .map(b => b.trim())
        .filter(Boolean)
        .map(b => {
          // Mark bars with < or > for alternate endings and @SPLIT@ for second ending start
          const hasOpenAngle = b.includes('<');
          const hasCloseAngle = b.includes('>');
          const isSplitPoint = b.includes('@SPLIT@');
          const content = b.replace(/[<>12]/g, '').replace(/@SPLIT@/g, ''); // Remove markers
          return { 
            content, 
            openAngle: hasOpenAngle, 
            closeAngle: hasCloseAngle,
            isSplitPoint: isSplitPoint
          };
        });
    }

    // Improved accidental logic
    function parseNotes(bar, key) {
      // Handle both string and object formats
      const barContent = typeof bar === 'string' ? bar : bar.content;
      const accidentals = keyAccidentals[key] || [];
      const tokens = barContent.match(/[_^]?[A-Ga-g][',]?[0-9]*/g) || [];

      return tokens.map(tok => {
        let dur = tok.match(/[0-9]+/);
        let len = dur ? `@${dur[0]}` : '';
        tok = tok.replace(/[0-9]/g, '');
        let acc = '';
        if (tok.startsWith('^')) acc = '^', tok = tok.slice(1);
        else if (tok.startsWith('_')) acc = '_', tok = tok.slice(1);

        const noteLetter = tok[0].toUpperCase();

        // Apply key signature sharps/flats if no explicit accidental
        if (!acc) {
          for (const accidental of accidentals) {
            if (accidental[0].toUpperCase() === noteLetter) {
              if (accidental[1] === '#') acc = '^';
              if (accidental[1] === 'b') acc = '_';
            }
          }
        }

        let octave = /[a-g]/.test(tok[0]) ? 5 : 4;
        if (tok.includes("'")) octave++;
        if (tok.includes(",")) octave--;

        const base = baseMap[acc + noteLetter] || tok[0].toLowerCase();
        return `${base}${octave}${len}`;
      }).join(' ');
    }

    // ---------- New helpers added ----------
    // Unified copy helper with async Clipboard API + execCommand fallback.
    function copyToClipboard(text) {
      // Prefer navigator.clipboard.writeText when available
      if (navigator.clipboard && navigator.clipboard.writeText) {
        // Optional permission query (informative) â€” still call writeText
        if (navigator.permissions && navigator.permissions.query) {
          return navigator.permissions.query({ name: 'clipboard-write' })
            .catch(() => ({ state: 'prompt' })) // ignore permission-query errors
            .then(() => navigator.clipboard.writeText(text));
        }
        return navigator.clipboard.writeText(text);
      }

      // Fallback to legacy execCommand
      return new Promise((resolve, reject) => {
        try {
          const ta = document.createElement('textarea');
          ta.value = text;
          ta.setAttribute('readonly', '');
          ta.style.position = 'absolute';
          ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.select();
          const ok = document.execCommand('copy');
          document.body.removeChild(ta);
          if (ok) resolve();
          else reject(new Error('execCommand copy failed'));
        } catch (err) {
          reject(err);
        }
      });
    }

    // Manual fallback modal if programmatic copy is blocked
    function showManualCopyModal(text) {
      // If modal already exists, remove it
      const existing = document.querySelector('.copy-overlay');
      if (existing) existing.remove();

      const overlay = document.createElement('div');
      overlay.className = 'copy-overlay';

      const box = document.createElement('div');
      box.className = 'copy-modal';

      const title = document.createElement('div');
      title.textContent = 'Automatic copy failed. Select the text below and press Ctrl/Cmd+C to copy:';
      box.appendChild(title);

      const ta = document.createElement('textarea');
      ta.value = text;
      box.appendChild(ta);

      const actions = document.createElement('div');
      actions.className = 'copy-actions';

      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.onclick = () => overlay.remove();

      const doneBtn = document.createElement('button');
      doneBtn.textContent = 'Done';
      doneBtn.onclick = () => overlay.remove();

      actions.appendChild(closeBtn);
      actions.appendChild(doneBtn);
      box.appendChild(actions);

      overlay.appendChild(box);
      document.body.appendChild(overlay);

      // Focus and select for easy manual copying
      ta.focus();
      ta.select();
    }

    let _copyTimeout = null;
    function indicateCopied() {
      const btn = document.querySelector('button[onclick="convertABC()"]');
      if (!btn) return;
      clearTimeout(_copyTimeout);
      const original = btn.textContent;
      btn.textContent = 'Copied!';
      _copyTimeout = setTimeout(() => { btn.textContent = original; }, 1400);
    }
    // ---------- end new helpers ----------

    function convertABC() {
      const input = document.getElementById('abcInput').value.trim();
      const sound = document.getElementById('sound').value;
      if (!input) return;

      const lines = input.split('\n');
      const header = parseHeader(lines);
      const bodyStart = lines.findIndex(l => /^K:/.test(l));
      let body = lines.slice(bodyStart + 1).join(' ');
      body = markRepeats(body);

      // Split bars but preserve [[ ... ]] as repeat blocks
      const repeatBlocks = [];
      const regex = /\[\[([^\]]+)\]\]/g;
      let match, lastIndex = 0;
      while ((match = regex.exec(body)) !== null) {
        const before = body.slice(lastIndex, match.index).trim();
        if (before) repeatBlocks.push(...splitBars(before));
        repeatBlocks.push({ repeat: true, content: match[1].trim() });
        lastIndex = regex.lastIndex;
      }
      const tail = body.slice(lastIndex).trim();
      if (tail) repeatBlocks.push(...splitBars(tail));

      const formattedBars = repeatBlocks.map(b => {
        if (typeof b === 'object' && b.repeat) {
          const innerBars = splitBars(b.content);
          
          // Find where alternate endings start and where the split point is
          let alternateStart = -1;
          let splitPoint = -1;
          let alternateEnd = -1;
          
          for (let i = 0; i < innerBars.length; i++) {
            if (innerBars[i].openAngle) {
              alternateStart = i;
            }
            if (innerBars[i].isSplitPoint) {
              splitPoint = i;
            }
            if (innerBars[i].closeAngle) {
              alternateEnd = i;
            }
          }
          
          const formattedInnerBars = innerBars.map((bar, idx) => {
            const notes = parseNotes(bar, header.key);
            let prefix = '';
            let suffix = '';
            let addNewlineAfter = false;
            
            // Add < at the start of alternate endings (before first ending)
            if (idx === alternateStart) {
              prefix = '<';
            }
            
            // Add newline at the last bar before split point
            if (splitPoint !== -1 && idx === splitPoint - 1) {
              addNewlineAfter = true;
            }
            
            // Add > at the end of alternate endings (after second ending)
            if (idx === alternateEnd) {
              suffix = '>';
            }
            
            return { formatted: `${prefix}[${notes}]${suffix}`, addNewlineAfter, isSplitPoint: bar.isSplitPoint };
          });
          
          // Group bars into lines (max 2 per line), respecting newlines for alternate endings
          const lines = [];
          let currentLine = [];
          
          for (let i = 0; i < formattedInnerBars.length; i++) {
            const barInfo = formattedInnerBars[i];
            
            if (barInfo.addNewlineAfter) {
              // Add this bar to current line, then end the line (first ending ends)
              currentLine.push(barInfo.formatted);
              lines.push(currentLine.join(' '));
              currentLine = [];
            } else if (barInfo.isSplitPoint) {
              // This is the start of second ending - start a new indented line
              const indentation = '                             '; // Align with bars above
              currentLine.push(indentation + barInfo.formatted);
            } else {
              // Normal bar - add to current line
              currentLine.push(barInfo.formatted);
              // If we have 2 bars and we're not at the end, start a new line
              if (currentLine.length === 2 && i < formattedInnerBars.length - 1) {
                lines.push(currentLine.join(' '));
                currentLine = [];
              }
            }
          }
          
          if (currentLine.length > 0) {
            lines.push(currentLine.join(' '));
          }
          
          return `[${lines.join(' \n')}] *2\n`;
        } else {
          return `[${parseNotes(b, header.key)}]`;
        }
      }).join('\n');

      const output =
`// ${header.title || 'Untitled'}
// ${header.meter || ''} ${header.rhythm || ''}
// ${header.key || ''}
// ${header.length || ''} notes
setcpm(1)

$: note(\`
${formattedBars}
\`).sound("${sound}")`;

      const outEl = document.getElementById('strudelOutput');
      outEl.textContent = output;

      // Try to copy the generated output to clipboard (smart flow)
      copyToClipboard(output)
        .then(() => {
          indicateCopied();
        })
        .catch(err => {
          console.warn('Auto-copy failed:', err);
          // show manual copy modal so the user can copy themselves
          showManualCopyModal(output);
        });
    }

    // Auto-convert + copy when the user pastes into the textarea
    (function attachPasteAutoConvert() {
      const abcInput = document.getElementById('abcInput');
      if (!abcInput) return;
      let _pasteTimer = null;
      abcInput.addEventListener('paste', (e) => {
        // Wait a tick so pasted content is inserted into textarea
        clearTimeout(_pasteTimer);
        _pasteTimer = setTimeout(() => {
          convertABC();
        }, 50);
      });
    })();

    // Optional: keyboard shortcut (Ctrl/Cmd+Enter) to convert manually
    (function attachShortcut() {
      const abcInput = document.getElementById('abcInput');
      if (!abcInput) return;
      abcInput.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
          e.preventDefault();
          convertABC();
        }
      });
    })();
  </script>
</body>
</html>
